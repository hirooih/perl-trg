#! /usr/local/bin/perl
#
#	Copyright (c) 1996 Hiroo Hayashi. All Rights Reserved.
#
#	$Id: perlsh,v 1.2 1996-11-12 15:35:59 hayashi Exp $	
#

package PerlSh;

use strict;
use Term::ReadLine;

use vars qw($PS1 $PS2 $HISTFILE $HISTSIZE $INPUTRC);

$PS1 = '> ';
$PS2 = '? ';
$HISTFILE = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlsh_history";
$HISTSIZE = 256;
$INPUTRC = ($ENV{HOME} || ((getpwuid($<))[7])) . "/.perlshrc";

package main;
if (-f $PerlSh::INPUTRC) {
  do $PerlSh::INPUTRC;
}

package PerlSh;

use vars qw($term);

&toplevel;			# never returns

sub toplevel {
    $term = new Term::ReadLine 'PerlSh';
    $term->StifleHistory($HISTSIZE);
    if (-f $HISTFILE) {
	$term->ReadHistory($HISTFILE)
	    or warn "perlsh: cannot read history file: $!\n";
    }

    sub quit {
	$term->WriteHistory($HISTFILE)
	    or warn "perlsh: cannot write history file: $!\n";
	exit (0);
    }
    $SIG{'INT'} = \&quit;

    my ($command, @result);
    while (defined($command = &reader)) {
	no strict;
	@result = eval ("package main; $command");
	use strict;
	if ($@) { print "Error: $@\n"; next; }
	printer (@result);
    }
    &quit;
}

sub reader {
    my ($line, $command);
    $command = '';
    while (1) {
	$line = $term->readline($command ? $PS2 : $PS1);
	return undef unless (defined $line);
	
	if ($line =~ /\\$/) {
	    chop $line; $command .= " $line";
	} else {
	    $command .= " $line";
	    return $command;
	}
    }
}

sub printer {
    my (@res) = @_;
    my ($i);
    foreach $i (@res) { print "$i\n"; }
}
